{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import glpk from \"glpk.js\"\n\n/**\n * Compute a matrix to check if the rectangle between two terminals is empty.\n *\n * On the matrix, m[i][j] is true if the rectangle between terminals i, j is empty.\n * As this matrix is symmetrical, only the lower half is filled.\n * @param {*} terminals terminals points to consider\n * @param {*} successors a neighboring table; see rfst.js:getSuccessors()\n * @returns the lower triangular matrix with empty rect info\n */\nfunction getEmptyRects(terminals, successors) {\n  const ret: boolean[][] = []\n  for (let i = 0; i < terminals.length; i++) {\n    ret[i] = []\n    for (let j = 0; j < i; j++) {\n      ret[i][j] = false\n    }\n  }\n  const set = (i, j) => {\n    if (i > j) {\n      ret[i][j] = true\n    } else if (i < j) {\n      ret[j][i] = true\n    }\n  }\n\n  for (let i = 0; i < terminals.length; i++) {\n    const p = terminals[i]\n    const [x, y] = p\n\n    let topDist = Infinity\n    let bottomDist = Infinity\n    let oldTopDist = Infinity\n    let oldBottomDist = Infinity\n    let topX = x\n    let bottomX = x\n\n    for (let j = successors.east[i]; j >= 0; j = successors.east[j]) {\n      const q = terminals[j]\n      const dx = q[0] - x\n      let dy = q[1] - y\n      // Are they on the same horizontal/vertical line\n      if (dx === 0 || dy === 0) {\n        set(i, j)\n        continue\n      }\n      if (dy > 0) {\n        // Q is above P\n        if (dy <= topDist) {\n          set(i, j)\n          if (q[0] > topX) {\n            oldTopDist = topDist\n            topX = q[0]\n          }\n          topDist = dy\n        } else if (q[0] === topX && dy <= oldTopDist) {\n          set(i, j)\n        }\n      } else {\n        // Q is below P\n        dy = -dy\n        if (dy <= bottomDist) {\n          set(i, j)\n          if (q[0] > bottomX) {\n            oldBottomDist = bottomDist\n            bottomX = q[0]\n          }\n          bottomDist = dy\n        } else if (q[0] === bottomX && dy <= oldBottomDist) {\n          set(i, j)\n        }\n      }\n    }\n  }\n  return ret\n}\n\nfunction isEmptyRect(emptyRects, i, j) {\n  if (i > j) {\n    return emptyRects[i][j]\n  } else if (i < j) {\n    return emptyRects[j][i]\n  } else {\n    return true\n  }\n}\n\n/**\n * Disjoin Set Union-Find data structure\n * Determines if two terminals are already connected, with a fast method to\n * join sets when they get linked.\n */\nclass DSUF {\n  map: any\n  constructor() {\n    this.map = new Map()\n  }\n\n  areConnected(i, j) {\n    return this.map.has(i) && this.map.get(i).has(j)\n  }\n\n  connect(i, j) {\n    const seti = this.map.get(i)\n    const setj = this.map.get(j)\n    if (!seti && !setj) {\n      const union = new Set([i, j])\n      this.map.set(i, union)\n      this.map.set(j, union)\n    } else if (!seti) {\n      setj.add(i)\n      this.map.set(i, setj)\n    } else if (!setj) {\n      seti.add(j)\n      this.map.set(j, seti)\n    } else if (seti !== setj) {\n      const [bigger, smaller] =\n        seti.size > setj.size ? [seti, setj] : [setj, seti]\n      smaller.forEach((t) => {\n        bigger.add(t)\n        this.map.set(t, bigger)\n      })\n      bigger.add(i)\n      bigger.add(j)\n    }\n  }\n\n  /**\n   * Given a member of a set, returns a canonical member of that set.\n   * The result won't change until the set is united with other set.\n   * @param {*} i The member to search\n   */\n  find(i) {\n    const set = this.map.get(i)\n    return set ? set.values().next().value : i\n  }\n}\n\n/**\n * Compute a minimum spanning tree for a set of terminals (Kruskal's Algorithm)\n * @param {*} edges list of all edges on the graph, with their lengths\n * @returns the list of edges on the mst\n */\nfunction mst(edges) {\n  edges.sort((a, b) => a.len - b.len)\n  const dsuf = new DSUF()\n  const ret: any[] = []\n  edges.forEach((e) => {\n    if (!dsuf.areConnected(e.p1, e.p2)) {\n      ret.push(e)\n      dsuf.connect(e.p1, e.p2)\n    }\n  })\n  return ret\n}\n\n/**\n * Computes the rectilineal (L1/Manhattan) distance between two terminals\n * @return distance between the two terminals\n */\nfunction RDIST(t1, t2) {\n  return Math.abs(t1[0] - t2[0]) + Math.abs(t1[1] - t2[1])\n}\n\n/**\n * Returns the distance between two points on a specified direction\n * @param {*} dir axis to measure\n * @param {*} a first point\n * @param {*} b second point\n * @returns distance between the points\n */\nfunction DSTDIR(dir, a, b) {\n  const axis = dir % 2\n  return Math.abs(a[axis] - b[axis])\n}\n\n/**\n * Returns the distance between two points on a direction perpendicular to\n * the specified one\n * @param {*} dir axis from which get the perpendicular\n * @param {*} a first point\n * @param {*} b second point\n * @returns distance between the points\n */\nfunction DSTDIRP(dir, a, b) {\n  const axis = 1 - (dir % 2)\n  return Math.abs(a[axis] - b[axis])\n}\n\n/**\n * Generates a Steiner point between two terminals\n * @param {*} dir direction on which to generate the Steiner (starting from a)\n * @param {*} a first point\n * @param {*} b second point\n */\nfunction SPOINT(dir, a, b) {\n  return dir % 2 ? [a[0], b[1]] : [b[0], a[1]]\n}\n\ntype Edge = { p1: number; p2: number; len: number }\n/**\n * Enumerates rectilineal edges for a terminal set.\n * Optionally can use empty rect info to reduce the number of edges\n * @param {*} terminals terminal points to consider\n * @param {*} emptyRects optional empty rects info to limit edges\n * @returns list of edges between choosen terminals\n */\nfunction getEdges(terminals, emptyRects = []): Edge[] {\n  // TODO: empty rects not implemented yet\n  const edges: Edge[] = []\n  for (let i = 0; i < terminals.length; i++) {\n    for (let j = i + 1; j < terminals.length; j++) {\n      edges.push({\n        p1: i,\n        p2: j,\n        len: RDIST(terminals[i], terminals[j]),\n      })\n    }\n  }\n  return edges\n}\n\nfunction getRmst(terminals, emptyRects = []) {\n  const edges = getEdges(terminals, emptyRects)\n  const theMst = mst(edges)\n  return theMst\n}\n\n/**\n * Compute a table of Bottleneck Steiner Distances (BSDs) between terminals\n * @param {*} mst the minimum spanning tree edges\n * @returns the BSD table\n */\nfunction getBSDs(mst) {\n  const edges = [{ p1: 0, p2: 0, len: 0 }, ...mst]\n  const adjacency = getAdjacency(mst)\n  const bsds = { parent: [] as any[], edge: [] as any[], adjacency, edges }\n  let next = mst.length + 1\n  bsds.parent[next] = bsds.edge[next] = null\n  for (let i = 1; i < edges.length; i++) {\n    let { p1: u, p2: v } = edges[i]\n    let pu = bsds.parent[u]\n    let pv = bsds.parent[v]\n\n    while (u !== v && pu && pv) {\n      u = pu\n      v = pv\n      pu = bsds.parent[u]\n      pv = bsds.parent[v]\n    }\n    if (!pu && !pv) {\n      next++\n      bsds.parent[u] = next\n      bsds.parent[v] = next\n      bsds.edge[u] = i\n      bsds.edge[v] = i\n    } else if (!pu && pv) {\n      bsds.parent[u] = pv\n      bsds.edge[u] = i\n    } else if (pu && !pv) {\n      bsds.parent[v] = pu\n      bsds.edge[v] = i\n    }\n  }\n  // Make sure there are no gaps\n  for (let i = 0; i <= next; i++) {\n    if (!bsds.parent[i]) bsds.parent[i] = null\n    if (!bsds.edge[i]) bsds.edge[i] = null\n  }\n  return bsds\n}\n\n/**\n * Finds the Bottleneck Steiner Distance in a previously computed BSD table\n * @param {*} bsds previously computed BSD table\n * @param {*} i first terminal\n * @param {*} j second terminal\n * @returns the BSD between the terminals\n */\nfunction bsd(bsds, i, j) {\n  if (i === j) return 0\n  let index = -1\n  while (i !== j) {\n    let ei = bsds.edge[i]\n    let ej = bsds.edge[j]\n    if (ei > index) index = ei\n    if (ej > index) index = ej\n    i = bsds.parent[i]\n    j = bsds.parent[j]\n  }\n  return bsds.edges[index].len\n}\n\n/**\n * Generates adjacency lists for each node of a graph\n * @param {*} edges all edges in the graph\n * @returns array of adjacency lists, indexed by node\n */\nfunction getAdjacency(edges) {\n  const ret: any[] = []\n  edges.forEach((edge, i) => {\n    const { p1, p2 } = edge\n    if (!ret[p1]) ret[p1] = []\n    if (!ret[p2]) ret[p2] = []\n    ret[p1].push({ edge: i, node: p2 })\n    ret[p2].push({ edge: i, node: p1 })\n  })\n  return ret\n}\n\n/**\n * Computes the MST measured according to the Bottleneck Steiner Distance\n * @param {*} terms terminal indices to consider (relative to the bsds terms)\n * @param {*} bsds bsd structure\n */\nfunction getBmst(terms, bsds) {\n  const edges: Edge[] = []\n  for (let i = 0; i < terms.length; i++) {\n    for (let j = i + 1; j < terms.length; j++) {\n      edges.push({\n        p1: i,\n        p2: j,\n        len: bsd(bsds, terms[i], terms[j]),\n      })\n    }\n  }\n  const theMst = mst(edges)\n  return theMst\n}\n\n/**\n * Computes the MST length according to the BSD\n * @param {*} terms terminal indices to consider (relative to the bsds terms)\n * @param {*} bsds bsd structure\n */\nfunction getBmstLength(terms, bsds) {\n  const theMst = getBmst(terms, bsds)\n  let total = 0\n  theMst.forEach((e) => {\n    total += e.len\n  })\n  return total\n}\n\n/**\n * Compute rectilinear full Steiner trees, or RFSTs, for a given set of terminals.\n *\n * @param {*} terminals terminals points to consider\n *   Eg:\n *   [[2, 1], [3, 7], ...]\n *\n * @returns an object with the RFSTs\n *   Eg:\n *   {\n *     terminals: [[2, 1], ...]\n *     fsts: [\n *       {\n *         terminalIndices: [3, 8, 21, 33],\n *         length: 123.45,\n *         steinerPoints: [[2, 7], ...],\n *         edges: [[3, 8], ...],\n *         status: 0,\n *         incompatibleFstIndices: [2, 4, 6, ...] // really needed?\n *       },\n *       ...\n *     ]\n *   }\n */\nfunction rfst(terminals) {\n  // Preprocessing\n  const successors = getSuccessors(terminals)\n  const emptyRects = getEmptyRects(terminals, successors)\n  const ub0 = getUb0(terminals, successors)\n  const mst = getRmst(terminals)\n  // const mstLen = mst.map(e => e.len).reduce((s, l) => s + l)\n  const bsds = getBSDs(mst)\n  const zt = getZt(terminals, successors, ub0, emptyRects, bsds)\n  const ub1 = getUb1(terminals, successors, zt)\n\n  // Growing some FSTs\n  const ctx = {\n    terminals,\n    successors,\n    emptyRects,\n    ub0,\n    bsds,\n    zt,\n    ub1,\n    fsp: [],\n    fsphash: {},\n  }\n  for (let dir = 0; dir < 2; dir++) {\n    for (let i = 0; i < terminals.length; i++) {\n      const fts = {\n        terms: [i],\n        longterms: [i, -1],\n        maxedges: [] as any[],\n        shortterm: [] as any[],\n        lrindex: [] as any[],\n        term_check: [] as any[],\n        hash: [] as any[],\n        length: 0,\n        dir: dir,\n        ubLength: 0,\n        ubShortleg: [Infinity, Infinity],\n        longindex: 0,\n      }\n      fts.maxedges[i] = 0\n      for (let j = 0; j < terminals.length; j++) {\n        fts.lrindex[j] = 0\n        fts.term_check[j] = false\n        fts.hash[j] = null\n      }\n      growFST(ctx, fts)\n    }\n  }\n\n  // Add MST edges too\n  mst.forEach(({ p1, p2, len }) => {\n    testAndSaveFst(ctx, {\n      terms: [p1, p2],\n      length: len,\n      dir: 0,\n      type: 1,\n    })\n  })\n\n  return { terminals, fsts: ctx.fsp }\n}\n\n/**\n * Generate a map from each element to its successors in each cardinal direction\n * @param {*} terminals terminal points to consider\n * @returns an object with arrays for each direction which map indices to successors\n */\nfunction getSuccessors(terminals) {\n  const { x: xOrdered, y: yOrdered } = getOrderedIndices(terminals)\n\n  const west: any[] = []\n  const east: any[] = []\n  const north: any[] = []\n  const south: any[] = []\n\n  for (let i = 0; i < terminals.length; i++) {\n    west[i] = east[i] = north[i] = south[i] = -1\n  }\n\n  for (let i = 1; i < terminals.length; i++) {\n    west[xOrdered[i]] = xOrdered[i - 1]\n    east[xOrdered[i - 1]] = xOrdered[i]\n    north[yOrdered[i]] = yOrdered[i - 1]\n    south[yOrdered[i - 1]] = yOrdered[i]\n  }\n\n  return { west, east, north, south }\n}\n\n/**\n * Orders terminals by each axis\n * @param {*} terminals terminal points to consider\n * @returns object with arrays of ordered indices for each axis\n */\nfunction getOrderedIndices(terminals) {\n  const indicesX = Array.from(Array(terminals.length).keys())\n  const indicesY = indicesX.slice()\n  indicesX.sort((a, b) => {\n    const [tax, tay] = terminals[a]\n    const [tbx, tby] = terminals[b]\n    if (tax > tbx) return 1\n    if (tax < tbx) return -1\n    if (tay > tby) return 1\n    if (tay < tby) return -1\n    return a - b\n  })\n  indicesY.sort((a, b) => {\n    const [tax, tay] = terminals[a]\n    const [tbx, tby] = terminals[b]\n    if (tay > tby) return 1\n    if (tay < tby) return -1\n    if (tax > tbx) return 1\n    if (tax < tbx) return -1\n    return a - b\n  })\n  return { x: indicesX, y: indicesY }\n}\n\n/**\n * Compute UB0 bounds\n * @param {*} terminals terminal points to consider\n * @param {*} successors successors for each axis\n * @returns UB0 object\n */\nfunction getUb0(terminals, successors) {\n  const dirs = [\"east\", \"south\", \"west\", \"north\"]\n  const ub0 = {}\n  dirs.forEach((d, di) => {\n    const succ = successors[d]\n    const arr: any[] = (ub0[d] = [])\n    terminals.forEach((p, i) => {\n      let bound = Infinity\n      for (let j = succ[i]; j >= 0; j = succ[j]) {\n        const p2 = terminals[j]\n        const d1 = DSTDIR(di, p, p2)\n        if (d1 > bound) break\n        const d2 = DSTDIRP(di, p, p2)\n        if (d1 > d2) {\n          const d3 = d1 + d2\n          if (d3 < bound) {\n            bound = d3\n          }\n        }\n      }\n      arr[i] = bound\n    })\n  })\n  return ub0\n}\n\n/**\n * Find short leg candidates for each terminal and direction\n * @returns zt object\n */\nfunction getZt(terminals, successors, ub0s, emptyRects, bsds) {\n  const dirs = [\"east\", \"south\", \"west\", \"north\"]\n  const zt = {}\n\n  dirs.forEach((d, di) => {\n    zt[d] = []\n    const dirp = dirs[[3, 2, 3, 2][di]]\n    const succ = successors[d]\n    const ub0 = ub0s[d]\n    const ub0p = ub0s[dirp]\n\n    for (let i = 0; i < terminals.length; i++) {\n      zt[d][i] = []\n      const p1 = terminals[i]\n      let limit = ub0[i]\n      for (let j = succ[i]; j >= 0; j = succ[j]) {\n        const p2 = terminals[j]\n        const d1 = DSTDIR(di, p1, p2)\n        if (d1 === 0) continue\n        if (d1 > limit) break\n        const d2 = DSTDIRP(di, p1, p2)\n        if (d2 === 0) break\n        const lr = isLeft(di, p1, p2) === [0, 1, 1, 0][di]\n        if (!lr) continue\n        if (d2 > ub0p[j]) continue\n\n        const b = bsd(bsds, i, j)\n        if (d1 > b) continue\n        if (d2 > b) continue\n        if (isEmptyRect(emptyRects, i, j)) {\n          // Candidate found\n          zt[d][i].push(j)\n        }\n      }\n    }\n  })\n  return zt\n}\n\n/**\n * Determines if p2 is at the left of the ray from p1 in direction dir\n * @param {*} dir the direction (east=0, south=1, west=2, north=3)\n * @param {*} p1 the first point\n * @param {*} p2 the second point\n * @returns 1 if p2 is strictly to the left, 0 otherwise\n */\nfunction isLeft(dir, p1, p2) {\n  const isRTL = [0, 1, 1, 0][dir]\n  const axis = [1, 0, 1, 0][dir]\n  const ret = isRTL ? p2[axis] >= p1[axis] : p2[axis] <= p1[axis]\n  return ret ? 1 : 0\n}\n\n/**\n * Compute UB1 bounds\n * @returns UB1 object\n */\nfunction getUb1(terminals, successors, zt) {\n  const dirs = [\"east\", \"south\", \"west\", \"north\"]\n  const ub1s: any = {}\n  dirs.forEach((d, di) => {\n    const succ = successors[d]\n    const ub1: any = (ub1s[d] = [])\n    const dzt = zt[d]\n    terminals.forEach((p1, i) => {\n      const shortLegCandidates = dzt[i]\n      if (!shortLegCandidates.length) {\n        ub1[i] = 0\n        return\n      }\n      const last = shortLegCandidates[shortLegCandidates.length - 1]\n      let bound = Infinity\n      const p3 = terminals[last]\n      const steiner = SPOINT(di, p1, p3)\n      const d3 = DSTDIRP(di, p1, p3)\n      for (let j = succ[last]; j >= 0; j = succ[j]) {\n        const p2 = terminals[j]\n        const d1 = DSTDIR(di, steiner, p2)\n        if (d1 > bound) break\n        const d2 = DSTDIRP(di, steiner, p2)\n        const lr = isLeft(di, p1, p2) === [0, 1, 1, 0][di]\n        if (lr && d3 > d2) {\n          bound = d1\n          break\n        }\n        if (d1 > d2) {\n          const d4 = d1 + d2\n          if (d4 < bound) {\n            bound = d4\n          }\n        }\n      }\n      ub1[i] = DSTDIR(di, p1, p3) + bound\n    })\n  })\n  return ub1s\n}\n\nfunction growFST(ctx, fst) {\n  const r = fst.terms[0]\n  const l = fst.terms[fst.terms.length - 1]\n  const lastlr = fst.lrindex[l]\n  const dirName = [\"east\", \"south\", \"west\", \"north\"][fst.dir]\n  const succ = ctx.successors[dirName]\n\n  const root = ctx.terminals[r]\n  const last = ctx.terminals[l]\n  let maxBackbone = Infinity\n\n  const lastDstDirp = DSTDIRP(fst.dir, root, last)\n\n  let needsRestore = false\n\n  for (;;) {\n    let i = fst.longterms[++fst.longindex]\n    let lr\n    let p\n    let dstdirp\n\n    if (i < -1) {\n      // No more candidates, and no more can be found\n      break\n    }\n\n    if (i === -1) {\n      // Dynamically add next candidate to longterms\n      for (i = succ[fst.longterms[fst.longindex - 1]]; i >= 0; i = succ[i]) {\n        p = ctx.terminals[i]\n        dstdirp = DSTDIRP(fst.dir, root, p)\n        if (dstdirp === 0) {\n          lr = 2\n          fst.lrindex[i] = 2\n          fst.shortterm[i] = 0\n          fst.longterms[fst.longindex] = i\n          fst.longterms[fst.longindex + 1] = -2\n          break\n        }\n\n        lr = isLeft(fst.dir, root, p)\n        const dirp = (fst.dir + (lr ? 1 : -1)) & 0x03\n        const dirpName = [\"east\", \"south\", \"west\", \"north\"][dirp]\n\n        // Find short leg candidate (if it exists)\n        const candidates = ctx.zt[dirpName][i].slice().reverse()\n        const j = candidates.find(\n          (k) => isLeft(fst.dir, root, ctx.terminals[k]) === lr\n        )\n        fst.shortterm[i] = j !== undefined ? j : -1\n\n        // Check upper bounds\n        let ub1 = 0\n        if (j >= 0) {\n          ub1 = ctx.ub1[dirpName][i]\n        }\n        let d1 = ctx.ub0[dirpName][i]\n        if (d1 < ub1) {\n          d1 = ub1\n        }\n        if (dstdirp > d1) continue\n\n        fst.lrindex[i] = lr\n        fst.longterms[fst.longindex] = i\n        fst.longterms[fst.longindex + 1] = -1\n        break\n      }\n      if (i < 0) {\n        // No further candidates\n        fst.longterms[fst.longindex] = -2\n        break\n      }\n    } else {\n      // next long leg candidate available in longterms\n      p = ctx.terminals[i]\n      lr = fst.lrindex[i]\n      dstdirp = DSTDIRP(fst.dir, root, p)\n    }\n\n    const dstdir = DSTDIR(fst.dir, last, p)\n\n    // Check if consecutive terminals share Steiner point\n    if (fst.terms.length >= 3 && dstdir === 0) continue\n\n    // Upd. max backbone length using empty diamond property\n    if (dstdirp < dstdir) {\n      const d1 = dstdir + dstdirp\n      if (d1 < maxBackbone) {\n        maxBackbone = d1\n      }\n    }\n\n    // Upd. max backbone length using empty rect property\n    if (fst.terms.length >= 2 && lr === lastlr && dstdirp < lastDstDirp) {\n      if (dstdir < maxBackbone) {\n        maxBackbone = dstdir\n      }\n    }\n\n    // Check length of new backbone segment\n    if (dstdir > maxBackbone) break\n\n    if (lr === 2) {\n      // Terminal is on the backbone. Save as type 1 and break.\n      if (fst.terms.length >= 2) {\n        fst.terms.push(i)\n        testAndSaveFst(ctx, {\n          ...fst,\n          length: fst.length + dstdir + dstdirp,\n          type: 1,\n        })\n        fst.terms.pop()\n      }\n      break\n    }\n\n    // Terminal on wrong side of long leg?\n    if (fst.terms.length >= 2 && lr === lastlr) continue\n\n    // Empty rect with last term?\n    if (!isEmptyRect(ctx.emptyRects, l, i)) continue\n\n    // Check if new backbone segment is longer than any BSD\n    let passBsd = true\n    let minBsd = Infinity\n    for (let j = 0; j < fst.terms.length; j++) {\n      const k = fst.terms[j]\n      let d1 = fst.maxedges[k]\n      if (dstdir > d1) {\n        d1 = dstdir\n        fst.maxedges[k] = d1\n        needsRestore = true\n      }\n      const b = bsd(ctx.bsds, i, k)\n      if (d1 > b) {\n        passBsd = false\n        break\n      }\n      if (b < minBsd) {\n        minBsd = b\n      }\n    }\n    if (!passBsd) continue\n    let newUbLength = fst.ubLength + minBsd\n\n    const dirp = (fst.dir + (lr + lr - 1)) & 3\n    const dirpName = [\"east\", \"south\", \"west\", \"north\"][dirp]\n\n    // Try to make a type 2 FST\n    let tryType1 = false\n    let tryGrowing = false\n\n    let j = fst.shortterm[i]\n    if (j < 0) tryType1 = true\n\n    // Is backbone rect empty?\n    if (!isEmptyRect(ctx.emptyRects, r, j)) tryType1 = true\n\n    // Check UB1\n    if (dstdirp > ctx.ub1[dirpName][i]) tryType1 = true\n\n    // Check BSD for each terminal in current tree\n    let q\n    if (!tryType1) {\n      q = ctx.terminals[j]\n      for (let j2 = 0; j2 < fst.terms.length; j2++) {\n        const k = fst.terms[j2]\n        let d1 = fst.maxedges[k]\n        let d2 = DSTDIRP(fst.dir, root, q)\n        let d3 = DSTDIRP(fst.dir, p, q)\n        if (d2 > d1) d1 = d2\n        if (d1 > d3) d3 = d1\n        if (d3 > bsd(ctx.bsds, i, k)) tryType1 = true\n        d3 = DSTDIR(fst.dir, p, q)\n        if (d1 > d3) d3 = d1\n        if (d3 > bsd(ctx.bsds, j, k)) tryType1 = true\n      }\n    }\n\n    // Check short leg upper bound\n    if (!tryType1) {\n      if (DSTDIRP(fst.dir, root, q) > fst.ubShortleg[lr ? 1 : 0])\n        tryGrowing = true\n\n      // Perform FST tests and save as type 2\n      if (!tryGrowing) {\n        fst.terms.push(i, j)\n        testAndSaveFst(ctx, {\n          ...fst,\n          length:\n            fst.length + DSTDIR(fst.dir, last, q) + DSTDIRP(fst.dir, root, p),\n          type: 2,\n        })\n        fst.terms.pop()\n        fst.terms.pop()\n      }\n    }\n\n    // Try to make a type 1 FST\n    // try_type1:\n    if (!tryGrowing) {\n      // Check UB0\n      if (dstdirp > ctx.ub0[dirpName][i]) continue\n\n      // Check BSD to each terminal in prev tree\n      let passBsd = true\n      for (let j2 = 0; j2 < fst.terms.length; j2++) {\n        const k = fst.terms[j2]\n        let d1 = fst.maxedges[k]\n        if (dstdirp > d1) d1 = dstdirp\n        if (d1 > bsd(ctx.bsds, k, i)) {\n          passBsd = false\n          break\n        }\n      }\n      if (!passBsd) continue\n\n      // Check if BSD upper bound is shorter than partial tree w/steiner\n      if (fst.length + dstdir > newUbLength) continue\n\n      // Check if BSD upper bound is shorter than partial tree\n      if (fst.length + dstdir + dstdirp > newUbLength) tryGrowing = true\n\n      // Do not make 2-terminal FSTs\n      if (fst.terms.length <= 1) tryGrowing = true\n\n      // Is backbone rectangle empty?\n      if (!isEmptyRect(ctx.emptyRects, r, i)) tryGrowing = true\n\n      // Check short leg upper bound\n      if (dstdirp > fst.ubShortleg[lr]) tryGrowing = true\n\n      // Perform FST tests and save type 1 tree\n      if (!tryGrowing) {\n        fst.terms.push(i)\n        newUbLength = testAndSaveFst(ctx, {\n          ...fst,\n          length: fst.length + dstdir + dstdirp,\n          type: 1,\n        })\n        fst.terms.pop()\n      }\n    }\n\n    // Try to grow the current tree\n    // try_growing:\n\n    // Should we generate larger FSTs?\n    if (fst.terms.length >= ctx.terminals.length) continue // maxFstSize??\n\n    // Upper bound (A)\n    let d1 = fst.ubShortleg[lr]\n    if (dstdirp < d1) d1 = dstdirp\n    const newUbShortleg: any[] = []\n    newUbShortleg[lr] = d1\n    d1 = fst.ubShortleg[1 - lr]\n    if (fst.terms.length >= 2) {\n      // Upper bound (B)\n      let d2 = ctx.ub0[dirpName][i]\n      if (minBsd < d2) d2 = minBsd\n      d2 -= dstdirp\n      if (d2 < d1) d1 = d2\n\n      // Upper bound (C)\n      if (dstdir < d1) d1 = dstdir\n\n      if (fst.terms.length >= 3) {\n        // Upper bound (D)\n        let lp = fst.terms[fst.terms.length - 2]\n        d2 = DSTDIRP(fst.dir, root, ctx.terminals[lp])\n        if (dstdirp < d2) d2 = dstdirp\n        d2 = DSTDIR(fst.dir, ctx.terminals[lp], p) - d2\n        if (d2 < d1) d1 = d2\n      }\n    }\n    newUbShortleg[1 - lr] = d1\n\n    fst.terms.push(i)\n    fst.maxedges[i] = dstdirp\n    growFST(ctx, {\n      ...fst,\n      length: fst.length + dstdir + dstdirp,\n      ubLength: newUbLength,\n      ubShortleg: newUbShortleg,\n    })\n    fst.terms.pop()\n  }\n\n  if (needsRestore) {\n    // Restore caller's maxedges by recomputing them from scratch...\n    let longLegMax = 0\n    for (let i = fst.terms.length - 1; i > 0; i--) {\n      const k = fst.terms[i]\n      const p = ctx.terminals[k]\n      let d1 = DSTDIRP(fst.dir, root, p)\n      if (longLegMax > d1) d1 = longLegMax\n      fst.maxedges[k] = d1\n      const j = fst.terms[i - 1]\n      const q = ctx.terminals[j]\n      d1 = DSTDIR(fst.dir, q, p)\n      if (d1 > longLegMax) longLegMax = d1\n    }\n    fst.maxedges[r] = longLegMax\n  }\n}\n\nfunction testAndSaveFst(ctx, fst) {\n  const size = fst.terms.length\n  const dir = fst.dir\n\n  let type = fst.type\n\n  // Is this FST too large?\n  if (size >= 2 ** 31 - 1) return fst.length // Doesn't really make sense here\n\n  if (size > 2) {\n    const b = getBmstLength(fst.terms, ctx.bsds)\n    if (fst.length >= b) return b\n  }\n\n  // Simple duplicate tests for size 3 and 4\n  if (dir === 1) {\n    if (size === 3) return fst.length\n    if (size === 4 && fst.type !== 1) return fst.length\n  }\n\n  if (size > 4) {\n    // No 2 terms on the long leg should share a steiner point\n    for (let i = 1; i < size; i++) {\n      const p = ctx.terminals[fst.terms[i]]\n      const q = ctx.terminals[fst.terms[i - 1]]\n      const d1 = DSTDIR(dir, p, q)\n      if (d1 === 0) return fst.length\n    }\n  } else if (size === 4) {\n    const p1 = ctx.terminals[fst.terms[0]]\n    const p2 = ctx.terminals[fst.terms[1]]\n    if (DSTDIR(dir, p1, p2) === 0) return fst.length\n    const p3 = ctx.terminals[fst.terms[2]]\n    const p4 = ctx.terminals[fst.terms[3]]\n    if (DSTDIR(dir, p3, p4) === 0) return fst.length\n\n    if (DSTDIR(dir, p2, p3) === 0) {\n      if (DSTDIRP(dir, p1, p4) !== 0) return fst.length\n      type = 3 // Cross\n    }\n  } else if (size === 3) {\n    // Make sure that 3-terminal FST is not degenerate\n    const p1 = ctx.terminals[fst.terms[0]]\n    const p2 = ctx.terminals[fst.terms[1]]\n    const p3 = ctx.terminals[fst.terms[2]]\n    const z12 =\n      (DSTDIR(dir, p1, p2) === 0 ? 1 : 0) + (DSTDIRP(dir, p1, p2) === 0 ? 1 : 0)\n    const z13 =\n      (DSTDIR(dir, p1, p3) === 0 ? 1 : 0) + (DSTDIRP(dir, p1, p3) === 0 ? 1 : 0)\n    const z23 =\n      (DSTDIR(dir, p2, p3) === 0 ? 1 : 0) + (DSTDIRP(dir, p2, p3) === 0 ? 1 : 0)\n    if (z12 + z13 > 1) return fst.length\n    if (z12 + z23 > 1) return fst.length\n    if (z13 + z23 > 1) return fst.length\n  }\n\n  // Check empty diamond property for transformed FST\n  let i = 0\n  let last = size - 1\n  if (type === 2) {\n    last = size - 2\n    if ((size & 1) === 0) i = 1 // type 2, even\n  } else if ((size & 1) !== 0) i = 1 // type 1, odd\n  const p1 = ctx.terminals[fst.terms[0]]\n  const p2 = ctx.terminals[fst.terms[size - 1]]\n  while (i < last) {\n    // Check skew diamond\n    let s1 = SPOINT(dir, p1, ctx.terminals[fst.terms[i]])\n    let s2 = SPOINT(dir, p2, ctx.terminals[fst.terms[i + 1]])\n    if (!diamondEmpty(ctx, s1, s2, fst.terms[i], dir)) return fst.length\n    i++\n    if (i >= last) break\n\n    // Check for flat segment\n    s1 = SPOINT(dir, p2, ctx.terminals[fst.terms[i]])\n    s2 = SPOINT(dir, p2, ctx.terminals[fst.terms[i + 1]])\n    if (!diamondEmpty(ctx, s1, s2, fst.terms[i], dir)) return fst.length\n    i++\n  }\n\n  // Test that corner flipped FST does not split into 2+ FST\n  const d1 = DSTDIRP(\n    ctx.terminals[fst.terms[size - 1]],\n    ctx.terminals[fst.terms[0]],\n    dir\n  )\n  i = size - (fst.type === 1 ? 3 : 4)\n  while (i > 0) {\n    if (\n      DSTDIRP(ctx.terminals[fst.terms[i]], ctx.terminals[fst.terms[0]], dir) <=\n      d1\n    ) {\n      return fst.length\n    }\n    i -= 2\n  }\n\n  // Check for duplicates\n  const hash = fst.terms.slice().sort().join(\",\")\n  const dupe = ctx.fsphash[hash]\n  if (dupe) {\n    if (dupe.length <= fst.length) {\n      return dupe.length\n    }\n    // The new one is shorter! Delete the old one\n    const idx = ctx.fsp.indexOf(dupe)\n    if (idx >= 0) {\n      ctx.fsp.splice(idx, 1)\n    }\n  }\n\n  // Build FST graph in edge list form\n  fst.pterms = fst.terms.map((t) => ctx.terminals[t])\n  buildRFSTGraph(ctx, fst)\n  const info = {\n    terminalIndices: fst.terms.map((t) => t + 1), // One-indexed, and must make a copy\n    steinerPoints: fst.steins,\n    edges: fst.edges.map((e) => [\n      e.p1 < fst.terms.length ? e.p1 + 1 : (e.p1 - fst.terms.length + 1) * -1,\n      e.p2 < fst.terms.length ? e.p2 + 1 : (e.p2 - fst.terms.length + 1) * -1,\n    ]),\n    length: fst.length,\n  }\n  ctx.fsp.push(info)\n  ctx.fsphash[hash] = info\n\n  return fst.length\n}\n\nfunction buildRFSTGraph(ctx, fst) {\n  const p1 = fst.pterms[0]\n  const p2 = fst.pterms[1]\n  fst.steins = []\n  fst.edges = []\n  const size = fst.terms.length\n\n  if (size <= 2) {\n    if (p1[0] !== p2[0] && p1[1] !== p2[1]) {\n      const p3 = p1[0] < p2[0] ? SPOINT(1, p1, p2) : SPOINT(1, p2, p1)\n      fst.steins.push(p3)\n      fst.edges.push({ p1: 0, p2: 2, len: RDIST(p1, p3) })\n      fst.edges.push({ p1: 1, p2: 2, len: RDIST(p2, p3) })\n      return\n    } else {\n      fst.edges.push({ p1: 0, p2: 1, len: RDIST(p1, p2) })\n      return\n    }\n  }\n\n  if (fst.type === 3) {\n    // Cross\n    const p3 = SPOINT(fst.dir, p1, p2)\n    fst.steins.push(p3)\n    for (let i = 0; i < 4; i++) {\n      fst.edges.push({ p1: i, p2: 4, len: RDIST(fst.pterms[i], fst.steins[0]) })\n    }\n    return\n  }\n\n  // Decide whether to build a normal or corner-flipped topology\n  let k = size - 1\n  if (fst.type === 2) k--\n  k = fst.terms[k]\n  if (fst.dir === 1 && fst.lrindex[k] === 1) {\n    // Build normal (unflipped) topology\n    let p1 = fst.type === 1 ? fst.pterms[0] : fst.pterms[size - 1]\n    let p2 = fst.pterms[size - 2]\n    for (let i = size - 3; i >= 0; i--) {\n      fst.steins[i] = SPOINT(fst.dir, p1, p2)\n      p1 = fst.pterms[0]\n      p2 = fst.pterms[i]\n    }\n  } else {\n    // Build corner-flipped topology\n    if (fst.type === 1) {\n      k = (size & 1) === 0 ? size - 1 : 0\n    } else {\n      k = (size & 1) === 0 ? 0 : size - 1\n    }\n    let p1 = fst.pterms[k]\n    let p2 = fst.pterms[1]\n    for (let i = 0; i < size - 2; i++) {\n      fst.steins[i] = SPOINT(fst.dir, p1, p2)\n      p1 = fst.pterms[size - 1]\n      p2 = fst.pterms[i + 2]\n    }\n  }\n\n  // Now that Steiner points are in their places, build edges\n  let j = 0\n  for (let i = 0; i < size - 2; i++) {\n    const nj = size + i\n    fst.edges.push({ p1: j, p2: nj })\n    fst.edges.push({ p1: nj, p2: i + 1 })\n    j = nj\n  }\n  fst.edges.push({ p1: j, p2: size - 1 })\n\n  const nedges = (size <= 2 ? 1 : fst.type === 3 ? 4 : 2 * size - 3) + 1\n  let includeCorner = true\n  for (let i = 0; i < nedges - 1; i++) {\n    const { p1: j, p2: k } = fst.edges[i]\n    const p1 = j < size ? fst.pterms[j] : fst.steins[j - size]\n    const p2 = k < size ? fst.pterms[k] : fst.steins[k - size]\n    if (includeCorner && p1[0] !== p2[0] && p1[1] !== p2[1]) {\n      // Can only happen once\n      includeCorner = false\n      const p3 = p1[0] < p2[0] ? SPOINT(1, p1, p2) : SPOINT(1, p2, p1)\n      fst.steins.push(p3)\n\n      // Introduce the corner point by replacing one edge by two\n      // (one at the end)\n      fst.edges[i] = {\n        p1: j,\n        p2: size + fst.steins.length - 1,\n        len: RDIST(p1, p3),\n      }\n      fst.edges.push({\n        p1: k,\n        p2: size + fst.steins.length - 1,\n        len: RDIST(p2, p3),\n      })\n    } else {\n      fst.edges[i].len = RDIST(p1, p2)\n    }\n  }\n}\n\nfunction diamondEmpty(ctx, p, q, i, dir) {\n  const dirName = [\"east\", \"south\", \"west\", \"north\"][dir]\n  const oppositeDirName = [\"east\", \"south\", \"west\", \"north\"][dir + 2]\n\n  let succ = ctx.successors[dirName]\n  const d = RDIST(p, q)\n\n  for (let j = succ[i]; j >= 0; j = succ[j]) {\n    const r = ctx.terminals[j]\n    const dstdir = DSTDIR(dir, r, q)\n    if (dstdir > d) break\n    const dstdirp = DSTDIRP(dir, r, q)\n    if (RDIST(r, p) < d && dstdir + dstdirp < d) {\n      return false\n    }\n  }\n\n  succ = ctx.successors[oppositeDirName]\n  for (let j = succ[i]; j >= 0; j = succ[j]) {\n    const r = ctx.terminals[j]\n    const dstdir = DSTDIR(dir, r, p)\n    if (dstdir > d) break\n    const dstdirp = DSTDIRP(dir, r, p)\n    if (RDIST(r, q) < d && dstdir + dstdirp < d) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Intermediate module to use glpk.js without async issues\n */\n\nconst constants = {\n  /* direction: */\n  GLP_MIN: 1 /* minimization */,\n  GLP_MAX: 2 /* maximization */,\n\n  /* kind of structural variable: */\n  GLP_CV: 1 /* continuous variable */,\n  GLP_IV: 2 /* integer variable */,\n  GLP_BV: 3 /* binary variable */,\n\n  /* type of auxiliary/structural variable: */\n  GLP_FR: 1 /* free (unbounded) variable */,\n  GLP_LO: 2 /* variable with lower bound */,\n  GLP_UP: 3 /* variable with upper bound */,\n  GLP_DB: 4 /* double-bounded variable */,\n  GLP_FX: 5 /* fixed variable */,\n\n  /* message level: */\n  GLP_MSG_OFF: 0 /* no output */,\n  GLP_MSG_ERR: 1 /* warning and error messages only */,\n  GLP_MSG_ON: 2 /* normal output */,\n  GLP_MSG_ALL: 3 /* full output */,\n  GLP_MSG_DBG: 4 /* debug output */,\n\n  /* solution status: */\n  GLP_UNDEF: 1 /* solution is undefined */,\n  GLP_FEAS: 2 /* solution is feasible */,\n  GLP_INFEAS: 3 /* solution is infeasible */,\n  GLP_NOFEAS: 4 /* no feasible solution exists */,\n  GLP_OPT: 5 /* solution is optimal */,\n  GLP_UNBND: 6 /* solution is unbounded */,\n}\n\nconst solve = async (lp, msgLevel) => {\n  const solve = (await (glpk as any)()).solve\n  return solve(lp, msgLevel)\n}\n\nfunction updateBestSolutionSet(edges, bbip) {\n  // TODO: original function accepts either a LP solution,\n  // a list of edge numbers, or a edge set (aka a bitmap).\n  // We're only dealing with the list for now.\n\n  const nedges = bbip.cip.edges.length\n  const edgeMask = new Set()\n\n  // We are given an explicit set of edges\n  for (let i = 0; i < edges.length; i++) {\n    edgeMask.add(edges[i])\n  }\n\n  // Compute length of this solution, in edge order\n  let length = 0\n  for (let i = 0; i < nedges; i++) {\n    if (edgeMask.has(i)) {\n      length += bbip.cip.edges[i].length\n    }\n  }\n\n  // Note: Original code deals with keeping track of the K best solutions,\n  // but we only need to keep the best one, so we simplified the code.\n\n  if (bbip.solution && length >= bbip.solution.length) {\n    // This solution is not the best\n    return false\n  }\n\n  bbip.solution = {\n    length,\n    edges: [],\n  }\n  for (let i = 0; i < nedges; i++) {\n    if (edgeMask.has(i)) {\n      bbip.solution.edges.push(i)\n    }\n  }\n\n  bbip.upperbound = length\n  return true\n}\n\n/**\n * Pre-compute some info for ub heuristic\n * @param {*} cip the hyperedge info from phase 1\n * @returns an object with...\n */\nfunction startupHeuristicUpperBound(cip) {\n  const { terminals, edges } = cip\n  const n = edges.length\n  const fstLen = edges.map((e) => e.length)\n  const mstLen: any[] = []\n  const rankings: any[] = []\n  let nranks = 0\n\n  // Compute MST length of each FST\n  for (let i = 0; i < n; i++) {\n    const terms = edges[i].terminalIndices.map((ti) => terminals[ti - 1])\n    const mst = getRmst(terms)\n    mstLen[i] = mst.map((e) => e.len).reduce((s, l) => s + l)\n  }\n  let ranking = computeFstRanking(fstLen, mstLen)\n  rankings[nranks++] = ranking\n\n  // Pretend each edge in the MST has length 1\n  for (let i = 0; i < n; i++) {\n    mstLen[i] = edges[i].terminalIndices.length - 1\n  }\n  ranking = computeFstRanking(fstLen, mstLen)\n  rankings[nranks++] = ranking\n\n  const mstEdges = sortedMstEdges(edges)\n\n  return {\n    rankings,\n    mstEdges,\n  }\n}\n\n/**\n * Produces a ranking of FSTs ordered by increasing (numerator / denominator)\n * @param {*} num list of numerators\n * @param {*} den list of denominators\n */\nfunction computeFstRanking(num, den) {\n  // To ensure stability, we round ratios to the 12th decimal place\n  const factor = 1000000000000\n  const indices = num.map((_, i) => i)\n  const ratios = indices.map(\n    (i) => Math.round((num[i] / den[i]) * factor) / factor\n  )\n  indices.sort((a, b) => ratios[a] - ratios[b])\n\n  const ranking: number[] = []\n  for (let i = 0; i < indices.length; i++) ranking[indices[i]] = i\n  return ranking\n}\n\n/**\n * Finds all of the MST edges and sorts them by increasing length\n * @param {*} edges the fsts we got from phase 1\n */\nfunction sortedMstEdges(edges) {\n  const mstEdges: number[] = []\n  for (let i = 0; i < edges.length; i++) {\n    if (edges[i].edges.length === 2) {\n      mstEdges.push(i)\n    }\n  }\n\n  mstEdges.sort((a, b) => edges[a].length - edges[b].length)\n\n  // Remove all non-MST edges from the list\n  // TODO\n\n  return mstEdges\n}\n\n/**\n * Takes an existing LP solution (a fractional lower bound for an\n * optimal Steiner tree) and attempts to perturb it into a feasible\n * integer solution. If this succeeds and we discover a shorter\n * solution than previously known, it becomes the current best feasible\n * integer solution.\n */\nfunction computeHeuristicUpperBound(solution, bbip) {\n  if (!bbip.ubip) {\n    bbip.ubip = startupHeuristicUpperBound(bbip.cip)\n  }\n\n  const oldUb = bbip.upperbound || Infinity\n  bbip.ubip.bestZ = oldUb\n\n  // Classify edges in 3 buckets by weight: 1s, fractions, and 0s\n  const edgesIntegral: number[] = []\n  const edgesFractional: number[] = []\n  const edgesZero: number[] = []\n\n  for (let i = 0; i < bbip.cip.edges.length; i++) {\n    const weight = solution.vars[\"e\" + i]\n    if (weight <= 0.00001) {\n      edgesZero.push(i)\n    } else if (weight + 0.00001 >= 1) {\n      edgesIntegral.push(i)\n    } else {\n      edgesFractional.push(i)\n    }\n  }\n\n  // Repeat the greedy heuristic once for each FST rank ordering\n  bbip.ubip.rankings.forEach((ranking, i) => {\n    // Sort the integral FSTs by rank only\n    edgesIntegral.sort(sortByRank(ranking))\n\n    // Sort the fractional FSTs by LP weight, then rank\n    edgesFractional.sort(sortByLpAndRank(solution.vars, ranking))\n\n    // Sort the zero-weight FSTs by rank only\n    edgesZero.sort(sortByRank(ranking))\n\n    // Try several greedy trees using this ordering of FSTs\n    const edgeList = [...edgesIntegral, ...edgesFractional, ...edgesZero]\n    // console.log('*** Try Trees [1] for i =', i, 'got edge list:', edgeList)\n    tryTrees(edgeList, bbip)\n\n    // Create a second ordering by placing MST edges last\n    edgeList.sort((a, b) => {\n      const la = bbip.cip.edges[a].edges.length\n      const lb = bbip.cip.edges[b].edges.length\n      if (la === 2 && lb !== 2) return 1\n      if (lb === 2 && la !== 2) return -1\n      return 0\n    })\n\n    // console.log('*** Try Trees [2] for i =', i, 'got edge list:', edgeList)\n\n    // Try a few greedy trees using this ordering\n    tryTrees(edgeList, bbip)\n  })\n\n  return bbip.ubip.bestZ < oldUb\n}\n\nfunction sortByRank(ranking) {\n  return (a, b) => ranking[a] - ranking[b]\n}\n\nfunction sortByLpAndRank(x, ranking) {\n  return (a, b) => {\n    const w1 = x[\"e\" + a]\n    const w2 = x[\"e\" + b]\n    if (w1 !== w2) return w1 - w2\n    return ranking[a] - ranking[b]\n  }\n}\n\n/**\n * Construct several trees according to the given sorted list of FSTs\n */\nfunction tryTrees(edgeList, bbip) {\n  const used = new Set()\n\n  // Construct the initial tree. Note which edges were used.\n  let l = ubKruskal(edgeList, used, bbip)\n\n  if (l === Infinity) return // No initial tree found\n\n  // Prepare a list to be able to quickly add an edge at the front\n  const tempEdges = [null, ...edgeList]\n\n  // Determine the limit of edges to try\n  let limit\n  for (limit = 2; 1 << limit < edgeList.length; limit++) {}\n\n  // Compute small absolute gap value\n  let smallGap = 0.0001 * Math.abs(bbip.ubip.bestZ || Infinity)\n  if (smallGap < 0.0001) smallGap = 0.0001 // Warn: scaled!\n\n  // Greedy local search\n  let haveReset = false\n  let orgLimit = limit\n  let oldL = Infinity\n  let k = edgeList.length + 1\n\n  for (let i = 0; i < edgeList.length; i++) {\n    let e = edgeList[i]\n    if (used.has(e)) continue\n\n    // Force edge e to be chosen first\n    tempEdges[0] = e\n\n    // Clear old used map\n    used.clear()\n\n    l = ubKruskal(tempEdges, used, bbip)\n\n    // If improved solution then replace tempEdges\n    if (l < oldL) {\n      k = 1\n      for (let j = 0; j < edgeList.length; j++) {\n        let e = edgeList[j]\n        if (used.has(e) || bbip.cip.edges[e].terminalIndices.length === 2) {\n          tempEdges[k++] = e\n        }\n      }\n      oldL = l\n\n      // Compute small absolute gap value\n      smallGap = 0.0001 * Math.abs(bbip.ubip.bestZ)\n      if (smallGap < 0.0001) smallGap = 0.0001 // Warn: scaled!\n    }\n\n    // If we are really close to optimum then restart and intensify search\n    let currGap = l - bbip.ubip.bestZ\n    if (!haveReset && currGap <= smallGap) {\n      // console.log('*** Intensify!! currGap =', currGap, '<= smallGap =', smallGap)\n      // Let the new limit be double, plus an a*x**2 term whose coefficient\n      // is linearly dependent on the gap\n      const fraction = (smallGap - currGap) / smallGap\n      const quadratic = Math.floor(fraction * orgLimit ** 2)\n      limit = 2 * orgLimit + quadratic\n\n      i = 0\n      haveReset = true\n    }\n\n    if (--limit <= 0) break\n  }\n}\n\n/**\n * Use Kruskal's algorithm (extended for hypergraphs) to greedily construct\n * a tree from the given sequence of FSTs. If this yields a better solution\n * than previously known, record it and update the upper bound.\n */\nfunction ubKruskal(edgeList, used, bbip) {\n  const nverts = bbip.cip.terminals.length\n  const nedges = edgeList.length\n\n  const dsuf = new DSUF()\n\n  let components = nverts\n  let length = 0\n  const treeEdges: any[] = []\n  // let ep1 = 0 // Not needed: just do treeEdges.push()\n  let ep2 = 0\n  let ep3 = nedges\n  while (components > 1) {\n    if (ep2 >= ep3) {\n      // FSTs ran out before tree constructed\n      length = Infinity\n      break\n    }\n    const e = edgeList[ep2++]\n    // console.log('% -- New iter: e =', e)\n    const mark = new Set()\n    let vp1 = 0\n    const vp2 = bbip.cip.edges[e].edges.length * 2\n    while (true) {\n      if (vp1 >= vp2) {\n        // No cycle! Include e in solution\n        // console.log('% No cycle, including', e)\n        treeEdges.push(e)\n        length += bbip.cip.edges[e].length\n        used.add(e)\n        // Unite all subtrees joined\n        const [i, ...roots] = Array.from(mark)\n        roots.forEach((j) => dsuf.connect(i, j))\n        components -= mark.size - 1\n        break\n      }\n      const tij = bbip.cip.edges[e].edges[vp1 >> 1][vp1 & 1] - 1\n      vp1++\n      if (tij < 0) continue\n      const oj = bbip.cip.edges[e].terminalIndices[tij] - 1\n      const j = dsuf.find(oj)\n\n      if (mark.has(j)) {\n        // console.log('% Cycle with', j, '/ was:', oj)\n        break\n      }\n      // console.log('% Mark', j)\n      mark.add(j)\n    }\n  }\n\n  // console.log('% ****** Got: [', treeEdges.join(', '), '], and', components === 1 ? 'is a' : 'no', 'solution')\n\n  if (components === 1) {\n    // A solution was found\n    if (updateBestSolutionSet(treeEdges, bbip)) {\n      bbip.ubip.bestZ = bbip.upperbound\n    }\n  }\n\n  return length\n}\n\n/**\n * Gets the constraint pool with the initial set of constraints\n * @param {*} data Problem data, including terminals, masks, and edges\n */\nfunction getConstraintPool(data) {\n  const nterms = data.terminals.length\n  const vertMask = new Set(data.initialVertMask)\n  const edgeMask = new Set(data.initialEdgeMask)\n  const pool: any[] = []\n\n  // Note: we don't need to count sizes first, because\n  // we don't deal with memory management ourselves\n\n  // Add constraint for spanning\n  pool.push({\n    name: \"spanning\",\n    vars: data.edges\n      .filter((_, i) => edgeMask.has(i))\n      .map((e, i) => ({\n        name: \"e\" + i,\n        coef: e.terminalIndices.length - 1,\n      })),\n    selected: true,\n    bnds: {\n      type: constants.GLP_FX, // =\n      lb: vertMask.size - 1,\n    },\n  })\n\n  // Generate one cutset constraint per terminal\n  data.terminals.forEach((_, i) => {\n    if (!vertMask.has(i)) return\n    pool.push({\n      name: \"cutset-\" + i,\n      vars: data.termTrees[i]\n        .filter((j) => edgeMask.has(j))\n        .map((j) => ({\n          name: \"e\" + j,\n          coef: 1,\n        })),\n      selected: true,\n      bnds: {\n        type: constants.GLP_LO, // >=\n        lb: 1,\n      },\n    })\n  })\n\n  // Generate one constraint per incompatible pair\n  // TODO ...\n\n  // Generate one constraint for each 2-SEC (Subtour Elimination Constraints)\n  const fsmask = new Set()\n  for (let i = 0; i < nterms; i++) {\n    const tlist: any = []\n    const counts = data.terminals.map((_) => 0)\n    const tmask = new Set()\n\n    if (!vertMask.has(i)) continue\n    data.termTrees[i].forEach((fs) => {\n      if (!edgeMask.has(fs)) return\n      fsmask.add(fs)\n      const fst = data.edges[fs]\n      fst.edges.forEach((edge) => {\n        edge.forEach((vtx) => {\n          if (vtx > 0) {\n            const j = fst.terminalIndices[vtx - 1] - 1\n            if (j <= i) return\n            if (!vertMask.has(j)) return\n            counts[j]++\n            if (tmask.has(j)) return\n            tmask.add(j)\n            tlist.push(j)\n          }\n        })\n      })\n    })\n    tlist.forEach((j) => {\n      if (counts[j] < 2) return\n      // Generate 2SEC {i, j}\n      pool.push({\n        name: \"2sec-\" + i + \",\" + j,\n        vars: data.termTrees[j]\n          .filter((fs) => fsmask.has(fs))\n          .map((fs) => ({\n            name: \"e\" + fs,\n            coef: 1,\n          })),\n        selected: false,\n        bnds: {\n          type: constants.GLP_UP, // <=\n          ub: 1,\n        },\n      })\n    })\n    data.termTrees[i].forEach((fs) => fsmask.delete(fs))\n  }\n\n  // Remove duplicate rows (we do it here instead of row-by-row)\n  const poolDupes = new Set()\n  const poolUniq = pool.filter((r) => {\n    const s = JSON.stringify({ ...r, name: null })\n    const ret = !poolDupes.has(s)\n    poolDupes.add(s)\n    return ret\n  })\n\n  return poolUniq\n}\n\n/**\n * Set up the LP problem instance for the initial constraints of the LP relaxation\n * @param {*} cip Problem data\n * @param {*} pool Constraint pool\n */\nfunction getInitialFormulation(cip, pool) {\n  const objective = {\n    direction: constants.GLP_MIN,\n    name: \"obj\",\n    vars: cip.edges.map((e, i) => ({\n      name: \"e\" + i,\n      coef: e.length,\n    })),\n  }\n\n  const binaries = cip.edges.map((_, i) => \"e\" + i)\n\n  const bounds = cip.edges.map((_, i) => ({\n    name: \"e\" + i,\n    type: constants.GLP_DB,\n    lb: 0,\n    ub: 1,\n  }))\n\n  return {\n    name: \"LP\",\n    objective,\n    // binaries,\n    bounds,\n    subjectTo: pool,\n  }\n}\n\n/**\n * Solve the current LP relaxation.\n * First we solve it using only the selected rows, then we check the\n * non-selected ones to determine if they fit the solution.\n * Each row that doesn't fit, gets selected for the next iteration.\n * This process repeats until all constraints are met, or there is no solution.\n */\nasync function solveLpOverConstraintPool(bbip) {\n  const pool = bbip.cpool\n  let solution\n  while (true) {\n    const tableaux = pool.filter((r) => r.selected)\n    const lp = { ...bbip.lp, subjectTo: tableaux }\n    solution = await solve(lp, constants.GLP_MSG_OFF)\n\n    if (solution.result.status !== constants.GLP_OPT) break\n\n    let anyViolations = false\n    for (let i = 0; i < pool.length; i++) {\n      const row = pool[i]\n      const slack = computeSlackValue(solution, row)\n\n      if (slack > 0.00001) continue // Not binding, much less violated\n      // Binding\n      if (row.selected) continue // Already in tableaux\n      if (slack < -0.00001) {\n        // Not in the tableaux, and violated. Add to tableaux\n        row.selected = true\n        anyViolations = true\n      }\n    }\n\n    // Done if no violations found\n    if (!anyViolations) break\n  }\n\n  // TODO: if (solution.result.status ===  glpk.GLP_OPT) ...\n\n  return {\n    status: solution.result.status,\n    z: solution.result.z,\n    name: solution.name,\n    time: solution.time,\n    vars: solution.result.vars,\n  }\n}\n\n/**\n * Computes the amount of slack (if any) for a coefficient row\n * with respect to a solution\n * @param {*} solution The solution to check against\n * @param {*} row The target row\n */\nfunction computeSlackValue(solution, row) {\n  const sv = solution.result.vars\n  const sum = row.vars.reduce((s, v) => s + v.coef * sv[v.name], 0)\n  switch (row.bnds.type) {\n    case constants.GLP_UP:\n      return row.bnds.ub - sum\n    case constants.GLP_FX:\n      return Math.abs(sum - row.bnds.lb)\n    case constants.GLP_LO:\n      return sum - row.bnds.lb\n  }\n  return 0\n}\n\nfunction createBBTree() {\n  let serial = 0\n  return {\n    nextSerial: () => serial++,\n    first: null,\n    heapBest: new Heap(nodeIsBetter),\n    heapWorst: new Heap(nodeIsWorse),\n  }\n}\n\nfunction nodeIsBetter(a, b) {\n  if (a.z < b.z) return true\n  if (a.z > b.z) return false\n  if (a.num >= b.num) return true\n  return false\n}\n\nfunction nodeIsWorse(a, b) {\n  return a.z >= b.z\n}\n\n/**\n * Binary heap class used to efficiently get the next interesting node\n */\nclass Heap {\n  isParent: (a: any, b: any) => boolean\n  array: any[]\n  indices: Map<any, any>\n  constructor(isParent) {\n    this.isParent = isParent\n    this.array = []\n    this.indices = new Map()\n  }\n\n  getRoot() {\n    return this.array[0]\n  }\n\n  insert(node) {\n    // Add it at the end, and sift it up\n    let i\n    for (i = this.array.length; i > 0; ) {\n      const j = (i - 1) >> 1\n      const node2 = this.array[j]\n      if (this.isParent(node2, node)) break\n      this.indices.set(node2, i)\n      this.array[i] = node2\n      i = j\n    }\n    this.indices.set(node, i)\n    this.array[i] = node\n  }\n\n  remove(node) {\n    // Find node being deleted\n    let i = this.indices.get(node)\n    if (i === undefined) return // Not found\n\n    // Deleted node is no longer here\n    this.indices.delete(node)\n\n    // Remove last element from heap\n    const node2 = this.array.pop()\n    if (node === node2) return // Removed last item, nothing to do\n\n    // Assume that node2 will be in position i\n    // First, sift it up...\n    while (i > 0) {\n      const j = (i - 1) >> 1\n      const node3 = this.array[j]\n      if (this.isParent(node3, node2)) break\n      this.indices.set(node3, i)\n      this.array[i] = node3\n      i = j\n    }\n\n    // Later, sift it down...\n    while (i < this.array.length) {\n      let j = (i << 1) + 1\n      if (j >= this.array.length) break\n      let node3 = this.array[j]\n      if (j + 1 < this.array.length) {\n        const node4 = this.array[j + 1]\n        if (this.isParent(node4, node3)) {\n          j++\n          node3 = node4\n        }\n      }\n      if (this.isParent(node2, node3)) break\n      this.indices.set(node3, i)\n      this.array[i] = node3\n      i = j\n    }\n    this.indices.set(node2, i)\n    this.array[i] = node2\n  }\n\n  size() {\n    return this.array.length\n  }\n}\n\n/**\n * Prepares the phase 1 results for further processing\n * @param {*} terminals the terminal list used in phase 1\n * @param {*} edges the fsts we got from phase 1\n * @returns an object with all required info\n */\nfunction prepare(terminals, edges) {\n  const initialVertMask = new Set(terminals.map((_, i) => i))\n  const initialEdgeMask = new Set(edges.map((_, i) => i))\n  const termTrees = getTermTrees(edges)\n\n  return {\n    terminals,\n    edges,\n    initialVertMask,\n    initialEdgeMask,\n    termTrees,\n  }\n}\n\n/**\n * Create the \"term_trees\" array that is indexed by point number\n * and gives a list of all tree-numbers involving that point\n * @param {*} edges the fsts we got from phase 1\n */\nfunction getTermTrees(edges) {\n  const termTrees: any[] = []\n  edges.forEach((fst, i) => {\n    fst.edges.forEach((edge) => {\n      edge.forEach((vtx) => {\n        if (vtx >= 0) {\n          const vtxIdx = fst.terminalIndices[vtx - 1] - 1\n          if (!termTrees[vtxIdx]) termTrees[vtxIdx] = []\n          if (termTrees[vtxIdx].indexOf(i) === -1) {\n            termTrees[vtxIdx].push(i)\n          }\n        }\n      })\n    })\n  })\n  return termTrees\n}\n\n/**\n * Create the branch-and-bound info object\n */\nfunction getBbInfo(cip) {\n  // Get pool of constraints\n  const cpool = getConstraintPool(cip)\n\n  // Get initial formulation\n  const lp = getInitialFormulation(cip, cpool)\n\n  // Initialize the branch-and-bound tree\n  const bbtree: any = createBBTree()\n\n  // Create vectors to describe the current problem\n  // TODO: We never have edge masks or required edges, so we're skipping this\n\n  // Create the root node\n  const root = {\n    z: -Infinity,\n    optimal: false,\n    num: bbtree.nextSerial(),\n    iter: 0,\n    parent: -1,\n    var: -1,\n    dir: 0,\n    depth: 0,\n    // ...\n  }\n\n  // Fill in the branch-and-bound info structure\n  const bbip = {\n    cpool,\n    lp,\n    bbtree,\n    cip,\n    prevlb: -Infinity,\n    bestZ: Infinity,\n    // ...\n  }\n\n  // Make the root node inactive by putting it in the bbtree\n  bbtree.first = root\n  bbtree.heapBest.insert(root)\n  bbtree.heapWorst.insert(root)\n\n  return bbip\n}\n\n/**\n * Main branch-and-cut algorithm\n * @param {*} cip hyperedge data from prepare()\n * @param {*} bbip data from getBbInfo()\n * @returns the minimum spanning tree\n */\nasync function branchAndCut(cip, bbip) {\n  // Get heuristic upper bound\n  bbip.ubip = startupHeuristicUpperBound(cip)\n\n  for (;;) {\n    // Select the next node to process\n    const node = selectNextNode(bbip.bbtree)\n    if (!node) break\n\n    // This is perhaps a new lower bound...\n    newLowerBound(node.z, bbip)\n\n    // ??? no idea why this was here -Seve\n    // if (node.z > -Infinity);\n\n    // Restore the LP tableaux and basis for this node\n    const lp = node.lp\n\n    // Determine new preemption value\n    const nextBest = bbip.bbtree.heapBest.getRoot()\n    bbip.preemptZ = nextBest ? nextBest.z : bbip.bestZ\n\n    // Mod LP to represent problem from new node (??)\n    // TODO ...\n\n    // Set up new node to be processed\n    bbip.node = node\n\n    // Process the current node\n    await computeGoodLowerBound(bbip)\n\n    break // TODO: No infinite loop!\n  }\n}\n\n/**\n * Select the next node to process from a given bb tree\n * @param {*} bbtree\n */\nfunction selectNextNode(bbtree) {\n  return bbtree.heapBest.getRoot()\n}\n\n/**\n * Computes the lower-bound for the current node, which consists of solving\n * the LP and generating violated constraints until either:\n * - It becomes infeasible\n * - Objective meets or exceeds cutoff value\n * - Solution is integral\n * - Separation finds no more violated constraints\n */\nasync function computeGoodLowerBound(bbip) {\n  while (true) {\n    let result = await solveLpOverConstraintPool(bbip)\n    const z = result.z\n    bbip.node.iter++\n\n    // console.log('  % Node', bbip.node.num, 'LP', bbip.node.iter, 'Solution, length =', z)\n\n    switch (result.status) {\n      case constants.GLP_OPT:\n        if (z >= bbip.bestZ) {\n          bbip.node.z = bbip.bestZ\n          return \"cutoff\"\n        }\n        break\n      // case glpk.cutoff: // We don't have cutoff\n      case constants.GLP_INFEAS:\n        bbip.node.z = bbip.bestZ\n        return \"infeasible\"\n      default:\n        throw new Error(\"Solve status = \" + result.status)\n    }\n\n    // Solution is feasible, check for integer-feasible...\n    const { isInt, numFractional } = integerFeasibleSolution(result, bbip.cip)\n\n    // Check if this node's objective value is now high enough to be preempted\n    if (bbip.node.z > bbip.preemptZ) {\n      // console.log('preempted')\n      return \"preempted\"\n    }\n\n    // Perhaps we have a new lower bound?\n    newLowerBound(z, bbip)\n\n    if (computeHeuristicUpperBound(result, bbip)) {\n      newUpperBound(bbip.upperbound, bbip)\n    }\n\n    // If we have improved the upper bound, it is possible\n    // that this node can now be cutoff\n    // TODO\n\n    // TODO: cp = do_separations() ...\n\n    {\n      // No more violated constraints found\n      break\n    }\n\n    // TODO: get rid of slack rows\n  }\n}\n\n/**\n * Checks if we have an integer feasible solution.\n * First we check for integrality, then we check connectedness.\n */\nfunction integerFeasibleSolution(solution, cip) {\n  let numFractional = 0\n\n  for (let i = 0; i < cip.edges.length; i++) {\n    if (solution.vars[\"e\" + i] <= 0.00001) continue\n    if (solution.vars[\"e\" + i] + 0.00001 >= 1) continue\n    numFractional++\n  }\n\n  if (numFractional) {\n    // There are fractional variables; solution is NOT integer feasible\n    return { isInt: false, numFractional }\n  }\n\n  // All solution variables are either 0 or 1 -- integral.\n  // Note all edges present in the solution\n  let j = 0\n  let startingEdge = -1\n  const integralEdges = new Set()\n  for (let i = 0; i < cip.edges.length; i++) {\n    // Object.keys(solution.vars).filter(v => solution.vars[v] >= 0.5))\n    if (solution.vars[\"e\" + i] >= 0.5) {\n      integralEdges.add(i)\n      startingEdge = i\n      j += cip.edges[i].terminalIndices.length - 1\n    }\n  }\n\n  // console.log('% *** j =', j, ', num_int', numInt)\n\n  if (j !== cip.terminals.length - 1) {\n    // Wrong cardinality of edges -- cannot be a tree\n    return { isInt: false, numFractional }\n  }\n\n  if (startingEdge < 0) {\n    // No edges in solution: problem must have one or fewer vertices.\n    // This is connected by default.\n    return { isInt: true, numFractional }\n  }\n\n  // Create temporary mask of vertices we have not yet seen\n  const vertsLeft = new Set(cip.terminals.map((_, i) => i))\n\n  // Find connected component containing the starting edge\n  integralEdges.delete(startingEdge)\n  const stack = [startingEdge]\n  while (stack.length) {\n    const fs = stack.pop()\n    cip.edges[fs!].terminalIndices.forEach((tpp) => {\n      const t = tpp - 1\n      if (!vertsLeft.has(t)) return\n      vertsLeft.delete(t)\n      cip.termTrees[t].forEach((fs2) => {\n        if (!integralEdges.has(fs2)) return\n        integralEdges.delete(fs2)\n        stack.push(fs2)\n      })\n    })\n  }\n\n  // See if any vertices were not reached\n  const notReached = vertsLeft.size !== 0\n\n  if (notReached) {\n    // At least one more connected component -- solution is not connected,\n    // and therefore infeasible (and at least one integer cycle)\n    return { isInt: false, numFractional }\n  }\n\n  // Solution is a Steiner tree! (Not necessarily minimal)\n  return { isInt: true, numFractional }\n}\n\n/**\n * Prints a new lower bound\n */\nfunction newLowerBound(lb, bbip) {\n  let prev = bbip.prevlb\n  if (lb <= prev) {\n    return // No improvement\n  }\n\n  if (prev <= -Infinity) {\n    prev = lb // Don't jump from initial value\n  }\n\n  // Print the old and new lower bounds\n  let oldGap, newGap\n  if (bbip.bestZ >= Infinity || bbip.bestZ === 0) {\n    oldGap = newGap = 99.9\n  } else {\n    oldGap = (100 * (bbip.bestZ - prev)) / bbip.bestZ\n    newGap = (100 * (bbip.bestZ - lb)) / bbip.bestZ\n  }\n\n  // TODO: Set solver preempt value...\n\n  // console.log(' % @LO', prev, oldGap)\n  // console.log(' % @LN', lb, newGap)\n\n  bbip.prevlb = lb\n}\n\n/**\n * Prints a new upper bound\n */\nfunction newUpperBound(ub, bbip) {\n  let prev = bbip.bestZ\n  if (prev >= Infinity) {\n    // Don't jump from infinity\n    prev = ub\n  }\n\n  let oldGap, newGap\n  if (bbip.prevlb <= -Infinity) {\n    oldGap = newGap = 99.9\n  } else {\n    oldGap = (100 * (prev - bbip.prevlb)) / prev\n    newGap = (100 * (ub - bbip.prevlb)) / ub\n  }\n\n  // TODO: Set solver preempt value...\n\n  // console.log(' % @UO', prev, oldGap)\n  // console.log(' % @UN', ub, newGap)\n}\n\n/**\n * Returns a standard solution format from a previously computed solution\n * @param {*} bbip problem and solution info\n */\nfunction buildSolution(bbip) {\n  const terminals = bbip.cip.terminals\n  const solution = bbip.solution\n  const length = solution.length\n  const steiners: any[] = []\n  const edges: any[] = []\n  const edgeIds: any[] = []\n  solution.edges.forEach((e) => {\n    const fst = bbip.cip.edges[e]\n    const steinerOffset = steiners.length\n    fst.steinerPoints.forEach((p) => steiners.push(p))\n\n    const id2absolute = (n) =>\n      n > 0 ? fst.terminalIndices[n - 1] : -steinerOffset + n\n    const id2coords = (n) => (n > 0 ? terminals[n - 1] : steiners[-n - 1])\n\n    fst.edges.forEach((v) => {\n      edgeIds.push(v.map(id2absolute))\n      edges.push(v.map(id2coords))\n    })\n  })\n\n  return {\n    terminals: terminals,\n    steiners: steiners,\n    edges: edges,\n    edgeIds: edgeIds,\n    length: length,\n  }\n}\n\n/**\n * Our wrapper function to simplify usage\n * @param {*} terminals the terminal list used in phase 1\n * @param {*} edges the fsts we got from phase 1\n */\nasync function bb(terminals, edges) {\n  const data = prepare(terminals, edges)\n  const bbip = getBbInfo(data)\n  await branchAndCut(data, bbip)\n  return buildSolution(bbip)\n}\n\n/**\n * Main entry point\n * @param {*} terminals List of terminals to use\n * @returns The RSMT for the given terminals\n */\nfunction rsmt(terminals) {\n  if (terminals.length < 2) {\n    return {\n      terminals,\n      steiners: [],\n      edges: [],\n      edgeIds: [],\n      length: 0,\n    }\n  }\n  const { fsts } = rfst(terminals)\n  return bb(terminals, fsts)\n}\n\nexport default rsmt\n"],"mappings":"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","names":["mst","dirp","dirpName","j","d1","passBsd","i","p1","p2","k","solve","glpk","e"]}